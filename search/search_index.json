{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenStack K8S Operators Architectures","text":"<p>The Architectures repository may be used with to create validated architectures (VAs), represented as custom resources (CRs) for openstack-k8s-operators. It may also be used to create deployed topologies (DTs) which should only be used for testing.</p>"},{"location":"dt/","title":"Deployed Topologies","text":"<p>All validated architectures (VAs) are deployed topologies (DTs), but not all DTs are VAs.</p> <p>DTs represent CI optimizations. We design them to test lots of things together so we can have as few of them as possible. Before proposing a new DT to test something, consider if an update to an existing DT will achieve the same result.</p>"},{"location":"contributing/documentation/","title":"Contributing to documentation","text":""},{"location":"contributing/documentation/#rendering-documentation-locally","title":"Rendering documentation locally","text":"<p>Install docs build requirements into virtualenv:</p> <pre><code>python3 -m venv local/docs-venv\nsource local/docs-venv/bin/activate\npip install -r docs/doc_requirements.txt\n</code></pre> <p>Serve docs site on localhost:</p> <pre><code>mkdocs serve\n</code></pre> <p>Click the link it outputs. As you save changes to files modified in your editor, the browser will automatically show the new content.</p>"},{"location":"contributing/documentation/#structure-and-content","title":"Structure and Content","text":"<p>The <code>MkDocs</code> output generates nice looking HTML pages that link to the content genereated by github.com.</p> <p>This is because the authors believe it's more valuable to have github.com/openstack-k8s-operators/architecture be navigable relative to the github pages which contain the CRs, than have all of the documentation isolated in the <code>docs</code> directory. Thus, there are non-relative links in the <code>MkDocs</code> content to the pages hosted on github.</p> <p>Though it's possible to create symbolic links to README files or link to a directory above the <code>docs</code> directory, the resulting HTML will contain invalid links unless all READMEs are moved out of the directories that they describe. However, this would make reading the CRs more complicated as they wouldn't have a corresponding README.</p> <p>Thus, if you add a new VA or DT, then please just link it in the <code>mkdocs.yml</code> file, similar to the way the HCI VA is linked, in to keep the <code>MkDocs</code> output up to date.</p>"},{"location":"wa/missing_nncp/","title":"Missing NNCPs","text":"<p>The kustomize command builds and results in the OpenStack control plane definitions and its dependent Custom Resources (CR). <pre><code>kustomize build architecture/examples/va/hci &gt; control-plane.yaml\n</code></pre> The <code>control-plane.yaml</code> file contains CRs for both <code>NMState</code> and <code>NodeNetworkConfigurationPolicy</code> (NNCP). When  <code>oc apply -f control-plane.yaml</code> is read, OpenShift will try to create the NNCPs while <code>NMState</code> Custom Resource Definitions (CRD) are still installing and produce a message noting that the resource mappings are not found: <pre><code>nmstate.nmstate.io/nmstate created\n[resource mapping not found for name:\n\"ostest-master-0\" namespace: \"openstack\" from \"control-plane.yaml\":\nno matches for kind \"NodeNetworkConfigurationPolicy\" in version \"nmstate.io/v1\"\nensure CRDs are installed first,\nresource mapping not found for name: \"ostest-master-1\" namespace: \"openstack\"\nfrom \"control-plane.yaml\": no matches for kind \"NodeNetworkConfigurationPolicy\"\nin version \"nmstate.io/v1\"\n</code></pre> Retrying <code>oc apply -f contol-plane.yaml</code> a few seconds later is likely to resolve the problem.</p>"},{"location":"wa/missing_nncp/#alternative-approach","title":"Alternative Approach","text":"<p>It's also possible to create CR files with less components and wait before applying each CR file. E.g. the file <code>nncp.yaml</code> would contain only <code>NodeNetworkConfigurationPolicy</code> CRs and <code>NMState</code> and other deployment related CRs could exist in another file like <code>deploy.yaml</code>. The following process may be used to do generate these files using kustomize.</p> <ul> <li>Modify the va/hci/kustomization.yaml file so that the last two lines contain only the deploy component configuration: <pre><code>components:\n- ../../lib/deploy\n</code></pre></li> <li>Generate a file with only <code>MetalLB</code> and <code>NMState</code> CRs: <pre><code>kustomize build architecture/examples/va/hci &gt; deploy.yaml\n</code></pre></li> <li>Modify the va/hci/kustomization.yaml file so that the last two lines contain only the nncp component configuration: <pre><code>components:\n- ../../lib/nncp\n</code></pre></li> <li>Generate a file with only <code>NNCP</code> CRs: <pre><code>kustomize build architecture/examples/va/hci &gt; nncp.yaml\n</code></pre> The above process may be continued for each component.</li> </ul> <p>Note that va/hci/kustomization.yaml is not the same file as examples/va/hci/kustomization.yaml. <code>/example/va/hci</code> is a specific example of a given VA where as <code>/va/hci</code> is a generic HCI VA that may be customised and shared in multiple examples or composed to make a larger VA.</p> <p>This process will work for VAs (and DTs) besides HCI, but the paths may be different. E.g. examples/va/nfv/sriov/kustomization.yaml differs from va/nfv/sriov/kustomization.yaml and the later is in an <code>nfv</code> subdirectory so each component is referred to using <code>- ../../../lib/</code> instead of <code>- ../../lib/</code>.</p>"}]}