{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenStack K8S Operators Architectures","text":"<p>The Architectures repository may be used with to create validated architectures (VAs), represented as custom resources (CRs) for openstack-k8s-operators. It may also be used to create deployed topologies (DTs) which should only be used for testing.</p>"},{"location":"dt/","title":"Deployed Topologies","text":"<p>All validated architectures (VAs) are deployed topologies (DTs), but not all DTs are VAs.</p> <p>DTs represent CI optimizations. We design them to test lots of things together so we can have as few of them as possible. Before proposing a new DT to test something, consider if an update to an existing DT will achieve the same result.</p>"},{"location":"contributing/cherry-picking/","title":"Getting your PR into a stable branch","text":"<p>After your PR merges into the main branch you should open a PR to cherry pick it into a stable branch if appropriate. For example, you may want your patch to be in the 18.0.0-proposed branch.</p> <p>If you anticipate that your PR should be cherry picked then please tag it accordingly. For example we have a needs-18.0.0-proposed-cherry-pick tag. If we think a patch should be in a stable branch, then we will apply that tag to your PR to remind you to follow up to send in a cherry pick.</p> <p>Please do not ask core maintainers to cherry pick your patch though we will be happy to review it and help merge it once the cherry pick PR has been submitted using one of the methods below.</p>"},{"location":"contributing/cherry-picking/#method-1","title":"Method 1","text":"<p>Add a comment like the following to the PR you wish to cherry pick. <pre><code>/cherrypick 18.0.0-proposed\n</code></pre> The openshift-cherrypick-robot will then attempt to create a new PR of the original PR (after it merges) with a cherry-pick of the same patch into the desired branch. There are examples of this in previous PRs in this repository.</p> <p>If there is a merge conflict, then method 1 will not work and you will need to use method 2.</p>"},{"location":"contributing/cherry-picking/#method-2","title":"Method 2","text":"<p>If you can send a PR to this repository then you can create a cherry pick using the <code>git</code> command line tools without requiring any additional privileges. For example, the following produces a cherry-pick within a personal fork of the architecture repository. <pre><code>git remote add upstream git@github.com:openstack-k8s-operators/architecture.git \ngit fetch upstream\ngit checkout -b 18.0.0-proposed upstream/18.0.0-proposed\ngit push origin 18.0.0-proposed\ngit log origin/main\ngit cherry-pick &lt;commit hash&gt;\ngit push origin 18.0.0-proposed\n</code></pre> You should then be able to use the github web interface to create the PR. Please add <code>(cherry picked from &lt;commit hash&gt;)</code> to the bottom of your commit message.</p>"},{"location":"contributing/common-pitfalls/","title":"Common Design Pitfalls","text":"<p>This document lists common pitfalls that have been observed in the process of creating and modifying VAs and DTs.</p>"},{"location":"contributing/common-pitfalls/#accidental-openstackcontrolplane-overwrites","title":"Accidental OpenStackControlPlane Overwrites","text":"<p>In general, it is a best practice to keep all kustomizations (<code>patches</code>, <code>replacements</code>, etc) for a particular resource in one <code>kustomization.yaml</code> file.</p> <p>In some cases it is necessary to only perform a subset of <code>OpenStackControlPlane</code> kustomizations at a certain stage of the deployment process. For instance, you might not want to kustomize an <code>OpenStackControlPlane</code> CR with certain data during its initial creation stage because that data is not yet available for use. In the case of a multi-stage deployment, it would make sense to have a separate <code>kustomization.yaml</code> file to add those kustomizations once the requisite data is available (perhaps during the data plane deployment stage).</p> <p>What is crucial to keep in mind is that any kustomizations to a resource in an earlier stage will be lost/overwritten in later stages where that same resource is modified if those stages do not reference the same <code>kustomization.yaml</code> that the earlier stage utilized.</p> <p>It is best to have a base <code>kustomization.yaml</code> for a given resource for all kustomizations common to all stages -- and all those stages should reference that <code>kustomization.yaml</code>. If later stages need specific changes for that resource, a separate <code>kustomization.yaml</code> can used to apply those additional kustomizations beyond the base ones.</p> <p>The use of common base files is preferred to creating two nearly-identical <code>kustomization.yaml</code> files; one for the earlier stage and one for a later stage. Keeping things DRY by using a common base will make future potential changes to the <code>kustomization.yaml</code> files less prone to error, as changes to the common file will automatically be picked up by all deployment stages.</p> <p>As an illustrative example of the best practice mentioned above, consider the following directory structure:</p> <pre><code>some_dt_or_va/control_plane/kustomization.yaml\nsome_dt_or_va/data_plane/kustomization.yaml\n</code></pre> <p>If the <code>data_plane/kustomization.yaml</code> needs to modify the <code>OpenStackControlPlane</code>, then it should reference <code>../control_plane/kustomization.yaml</code> as a <code>Component</code> and then add additional <code>replacements</code> and/or <code>patches</code> as needed. </p> <p>If it were to instead reference this repositories lib/control-plane directory as its base <code>OpenStackControlPlane</code> <code>Component</code>, then the <code>../control_plane/kustomization.yaml</code> kustomizations would be lost, since the <code>OpenStackControlPlane</code> CR would be generated and applied without them.</p> <p>The kustomizations for an <code>OpenStackControlPlane</code> resource should be within a single <code>kustomization.yaml</code> that contains the kustomizations for the initial creation stage. You want to avoid the use of multiple files, such as creating an additional sub-directory within the same base directory containing the configuration. The following would be an example to avoid:</p> <pre><code>some_dt_or_va/control_plane/kustomization.yaml\nsome_dt_or_va/control_plane/some_subdir/kustomization.yaml\nsome_dt_or_va/data_plane/kustomization.yaml\n</code></pre> <p>In some cases having an additional nested directory may be valid, in the case a subdirectory was modifying some other resource like <code>NodeNetworkConfigurationPolicy</code>.</p> <p>If later stages do not want to accidentally overwrite earlier <code>OpenStackControlPlane</code> kustomizations, those later stages need to reference both <code>../control_plane/kustomization.yaml</code> and <code>../control_plane/some_subdir/kustomization.yaml</code> so that those stages are modifying the <code>OpenStackControlPlane</code>.</p> <p>It would be better for the two directories to be collapsed into one, such that a single <code>kustomization.yaml</code> can be referenced as a <code>Component</code> to include all the previous stage's kustomizations and not inadvertently overwrite them.</p>"},{"location":"contributing/documentation/","title":"Contributing to documentation","text":""},{"location":"contributing/documentation/#rendering-documentation-locally","title":"Rendering documentation locally","text":"<p>Install docs build requirements into virtualenv:</p> <pre><code>python3 -m venv local/docs-venv\nsource local/docs-venv/bin/activate\npip install -r docs/doc_requirements.txt\n</code></pre> <p>Serve docs site on localhost:</p> <pre><code>mkdocs serve\n</code></pre> <p>Click the link it outputs. As you save changes to files modified in your editor, the browser will automatically show the new content.</p>"},{"location":"contributing/documentation/#structure-and-content","title":"Structure and Content","text":"<p>The <code>MkDocs</code> output generates nice looking HTML pages that link to the content genereated by github.com.</p> <p>This is because the authors believe it's more valuable to have github.com/openstack-k8s-operators/architecture be navigable relative to the github pages which contain the CRs, than have all of the documentation isolated in the <code>docs</code> directory. Thus, there are non-relative links in the <code>MkDocs</code> content to the pages hosted on github.</p> <p>Though it's possible to create symbolic links to README files or link to a directory above the <code>docs</code> directory, the resulting HTML will contain invalid links unless all READMEs are moved out of the directories that they describe. However, this would make reading the CRs more complicated as they wouldn't have a corresponding README.</p> <p>Thus, if you add a new VA or DT, then please just link it in the <code>mkdocs.yml</code> file, similar to the way the HCI VA is linked, in to keep the <code>MkDocs</code> output up to date.</p>"},{"location":"contributing/pull-request-testing/","title":"Opening pull requests","text":"<p>Contributions to the <code>architecture</code> repository are always welcomed and encouraged. In order to avoid causing regressions to the repository and to prove that the contributions are working as intended, all pull requests are expected to provide proof of validation.</p> <p>The simplest way is to use the reproducer functionality in the CI-Framework.</p>"},{"location":"contributing/pull-request-testing/#using-the-reproducer-role","title":"Using the reproducer role","text":"<p>Additional parameters can be passed to the reproducer role of the CI-Framework, allowing you validate changes to the architecture repository remain functional within the contexts of kustomize and CI-Framework itself (which consumes the contents of the architecture repository).</p> <p>Use the <code>reproducer.yml</code> playbook within the CI-Framework to deploy the HCI validated architecture aka VA1 (or any other validated architecture or deployment topology that might be affected) with an environment file containing parameters denoting which branch and repository to deploy with. The custom parameter filename is not important, as long as it is passed to Ansible, and is valid.</p> <pre><code>ansible-playbook reproducer.yml \\\n    -i custom/inventory.yml \\\n    -e cifmw_target_host=hypervisor-1 \\\n    -e @scenarios/reproducers/va-hci.yml \\\n    -e @scenarios/reproducers/networking-definition.yml \\\n    -e @custom/default-vars.yaml \\\n    -e @custom/secrets.yml \\\n    -e @custom/test-my_pr_branch.yml\n</code></pre> <p>The <code>test-my_pr_branch.yml</code> file contains parameters that identifies the remote git repository and branch name to deploy.</p> <p>test-my_pr_branch.yml</p> <pre><code>remote_base_dir: \"/home/zuul/src/github.com/openstack-k8s-operators\"\ncifmw_reproducer_repositories:\n- src: \"https://github.com/&lt;FORKED_ORGANIZATION&gt;/architecture\"\n  dest: \"{{ remote_base_dir }}/architecture\"\n  version: &lt;BRANCH_TO_DEPLOY&gt;\n</code></pre> <p>Once your environment has been deployed, provide any relevant output showing that the deployment was successful, and that the environment continues to operate nominally. Provide any additional output showing that the changes to the architecture repository have been deployed and are functioning as intended by the pull request. You can SSH into the controller-0 machine and review the contents of <code>/home/zuul/src/github.com/openstack-k8s-operators/architecture</code> which contains the content as configured by the <code>test-&lt;NAME&gt;.yml</code> parameter file.</p>"},{"location":"faq/cr_by_components/","title":"Creating Smaller CRs","text":""},{"location":"faq/cr_by_components/#question","title":"Question","text":"<p>The kustomize command builds and results in the OpenStack control plane definitions and its dependent Custom Resources (CR). <pre><code>kustomize build architecture/examples/va/hci &gt; control-plane.yaml\n</code></pre> The <code>control-plane.yaml</code> file contains CRs for the <code>NodeNetworkConfigurationPolicy</code> (NNCP), the <code>NetworkAttachmentDefinition</code>, MetalLB resources and OpenStack resources. Is it possible to create a CR file with less custom resources?</p>"},{"location":"faq/cr_by_components/#answer","title":"Answer","text":"<p>Yes, it's possible to create CR files with less components and wait before applying each CR file. E.g. the file <code>nncp.yaml</code> would contain only <code>NodeNetworkConfigurationPolicy</code> CRs and <code>NetworkAttachmentDefinition</code> and other CRs could exist in another file like <code>networking.yaml</code>. The following process may be used to generate these files using kustomize.</p> <ul> <li>Modify the va/hci/kustomization.yaml file so that the components list only has the nncp component: <pre><code>components:\n- ../../lib/nncp\n</code></pre></li> <li>Generate a file with only NNCP CRs: <pre><code>kustomize build architecture/examples/va/hci &gt; nncp.yaml\n</code></pre></li> <li>Modify the va/hci/kustomization.yaml file so that the components list only has the networking component: <pre><code>components:\n- ../../lib/networking\n</code></pre></li> <li>Generate a file with only Networking CRs: <pre><code>kustomize build architecture/examples/va/hci &gt; networking.yaml\n</code></pre></li> </ul> <p>The above process may be continued for each component.</p> <p>Note that va/hci/kustomization.yaml is not the same file as examples/va/hci/kustomization.yaml. <code>/example/va/hci</code> is a specific example of a given VA where as <code>/va/hci</code> is a generic HCI VA that may be customised and shared in multiple examples or composed to make a larger VA.</p> <p>This process will work for VAs (and DTs) besides HCI, but the paths may be different. E.g. examples/va/nfv/sriov/kustomization.yaml differs from va/nfv/sriov/kustomization.yaml and the later is in an <code>nfv</code> subdirectory so each component is referred to using <code>- ../../../lib/</code> instead of <code>- ../../lib/</code>.</p>"}]}